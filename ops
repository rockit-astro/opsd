#!/usr/bin/env python3
#
# This file is part of opsd.
#
# opsd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# opsd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with opsd.  If not, see <http://www.gnu.org/licenses/>.

"""Commandline client for communicating with the operations daemon"""

import datetime
import glob
import json
import os
import sys
import Pyro4
from warwick.observatory.common import TFmt
from warwick.observatory.operations import (
    Config,
    CommandStatus,
    ConditionStatus,
    DomeStatus,
    OperationsMode,
    validate_schedule
)

SCRIPT_NAME = os.path.basename(sys.argv[0])

sys.excepthook = Pyro4.util.excepthook


def run_command(command, args):
    """Runs a daemon command, handling error messages"""
    if 'OPSD_CONFIG_PATH' in os.environ:
        config = Config(os.environ['OPSD_CONFIG_PATH'])
    else:
        # Load the config file defined in the OPSD_CONFIG_PATH environment variable or from the
        # default system location (/etc/teld/). Exit with an error if zero or multiple are found.
        files = glob.glob("/etc/opsd/*.json")
        if len(files) != 1:
            print('error: failed to guess the default config file. ' +
                  'Run as OPSD_CONFIG_PATH=/path/to/config.json ops <command>')
            return 1

        config = Config(files[0])

    try:
        ret = command(config, args)
    except Pyro4.errors.CommunicationError:
        ret = -101

    # Print message associated with error codes, except for -1 (error handled locally)
    if ret not in (0, -1):
        print(CommandStatus.message(ret))
    return ret


def dome_control(config, args):
    """Changes the dome between automatic and manual control and cancels automated observing"""
    if args:
        if args[0] == 'clear':
            with config.daemon.connect() as ops:
                return ops.clear_dome_window()

        if args[0] in ['auto', 'manual']:
            with config.daemon.connect() as ops:
                return ops.dome_control(args[0] == 'auto')

    print('usage: {} dome (auto|manual|clear)'.format(SCRIPT_NAME))
    return -1


def tel_control(config, args):
    """Changes the telescope between automatic and manual control and cancels automated observing"""
    if args:
        if args[0] == 'stop':
            with config.daemon.connect() as ops:
                return ops.stop_telescope()

        if args[0] in ['auto', 'manual']:
            with config.daemon.connect() as ops:
                return ops.tel_control(args[0] == 'auto')

    print('usage: {} tel (auto|manual|stop)'.format(SCRIPT_NAME))
    return -1


def validate_schedule_json(config, args):
    """checks a schedule file for errors"""
    if len(args) != 1:
        print('usage: {} schedule <observation json>'.format(SCRIPT_NAME))
        return -1

    try:
        with open(args[0], 'r') as infile:
            schedule = json.load(infile)
    except FileNotFoundError:
        print('error: file ' + args[0] + ' not found')
        return -1
    except Exception as e:
        print('error: invalid json file')
        print('error was: ' + str(e))
        return -1

    valid, errors = validate_schedule(schedule, config, False)
    status = TFmt.Green + 'PASSED' if valid else TFmt.Red + 'FAILED'
    print('Validation ' + TFmt.Bold + status + TFmt.Clear)
    for e in errors:
        print('   ' + e)

    return -1


def schedule(config, args):
    """Schedule observations for a nights observing"""
    if len(args) != 1:
        print('usage: {} schedule <observation json>'.format(SCRIPT_NAME))
        return -1

    try:
        with open(args[0], 'r') as infile:
            schedule = json.load(infile)
    except FileNotFoundError:
        print('error: file ' + args[0] + ' not found')
        return -1
    except Exception as e:
        print('error: invalid json file')
        print('error was: ' + str(e))
        return -1

    # Make sure the schedule is valid first!
    valid, errors = validate_schedule(schedule, config, True)
    if not valid:
        print('error: invalid json file:')
        for e in errors:
            print('   ' + e)
        return -1

    with config.daemon.connect() as ops:
        return ops.schedule_observations(schedule)

    return -1


def print_status(config, _):
    """Prints the latest ops data in machine-readable form"""
    try:
        with config.daemon.connect() as ops:
            status = ops.status()
    except Pyro4.errors.CommunicationError:
        print('error: unable to communicate with the operations daemon')
        return 1

    env_date = datetime.datetime.strptime(status['environment']['updated'], '%Y-%m-%dT%H:%M:%SZ')
    env_status = 'Environment status at ' + TFmt.Bold + env_date.strftime('%H:%M:%S') + TFmt.Clear + ': '
    if status['environment']['safe']:
        env_status += TFmt.Bold + TFmt.Green + 'SAFE' + TFmt.Clear
    else:
        env_status += TFmt.Bold + TFmt.Red + 'UNSAFE' + TFmt.Clear
    print(env_status)

    for label, sensors in status['environment']['conditions'].items():
        line = '{:>17}'.format(label) + ': '
        line += ', '.join([ConditionStatus.format_label(s, label) for label, s in sensors.items()])
        print(line)
    print()

    dome = status['dome']
    dome_date = datetime.datetime.strptime(dome['status_updated'], '%Y-%m-%dT%H:%M:%SZ')
    print('Dome status at ' + TFmt.Bold + dome_date.strftime('%H:%M:%S') + TFmt.Clear + ':')

    dome_mode = '    Control: ' + OperationsMode.label(dome['mode'], True)
    if dome['mode'] != dome['requested_mode']:
        dome_mode += ' (' + OperationsMode.label(dome['requested_mode'], True) + ' queued)'
    print(dome_mode)

    if dome['mode'] == OperationsMode.Automatic:
        open_str = TFmt.Yellow + 'Not Scheduled'
        if dome['requested_open_date']:
            open_str = dome['requested_open_date']
        print('     Opening: ' + TFmt.Bold + open_str + TFmt.Clear)

        close_str = TFmt.Yellow + 'Not Scheduled'
        if dome['requested_close_date']:
            close_str = dome['requested_close_date']
        print('     Closing: ' + TFmt.Bold + close_str + TFmt.Clear)

        dome_status = '    Shutters: ' + DomeStatus.label(dome['status'], True)
        print(dome_status)

    tel = status['telescope']
    tel_date = datetime.datetime.strptime(tel['status_updated'], '%Y-%m-%dT%H:%M:%SZ')
    print('Telescope status at ' + TFmt.Bold + tel_date.strftime('%H:%M:%S') + TFmt.Clear + ':')

    tel_mode = '    Control: ' + OperationsMode.label(tel['mode'], True)
    if tel['mode'] != tel['requested_mode']:
        tel_mode += ' (' + TFmt.Bold + OperationsMode.label(tel['requested_mode'], True) + ' queued)'

    print(tel_mode)

    if 'action_name' in tel:
        name = '       Name: ' + TFmt.Bold + tel['action_name'] + TFmt.Clear
        if tel['action_number'] > 0:
            name += ' (' + str(tel['action_number']) + ' of ' + str(tel['action_count']) + ')'
        print(name)

        if tel['action_task']:
            print('       Task: ' + TFmt.Bold + tel['action_task'] + TFmt.Clear)
    elif tel['mode'] == 1:
        print('    Action name: ' + TFmt.Bold + 'IDLE' + TFmt.Clear)

    return 0


def print_json(config, _):
    """Prints the latest ops data in machine-readable form"""
    try:
        with config.daemon.connect() as ops:
            status = ops.status()
    except Pyro4.errors.CommunicationError:
        print('error: unable to communicate with the operations daemon')
        return 1

    print(json.dumps(status))

    return 0


def print_usage():
    """Prints the utility help"""
    print('Usage: {} <command>'.format(SCRIPT_NAME))
    print()
    print('   json         print a machine-readable summary of the operations status')
    print('   status       print a human-readable summary of the operations status')
    print('   dome         toggle dome between manual and automatic control or clear schedule')
    print('   tel          toggle telescope between manual and automatic control or cancel actions')
    print('   validate     checks a schedule file for errors')
    print('   schedule     schedule observations for the night')
    print()

    return 1


if __name__ == '__main__':
    commands = {
        'status': print_status,
        'json': print_json,
        'dome': dome_control,
        'tel': tel_control,
        'validate': validate_schedule_json,
        'schedule': schedule
    }

    if len(sys.argv) >= 2 and sys.argv[1] in commands:
        sys.exit(run_command(commands[sys.argv[1]], sys.argv[2:]))

    sys.exit(print_usage())
