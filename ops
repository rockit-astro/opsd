#!/usr/bin/env python3.6
#
# This file is part of opsd.
#
# opsd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# opsd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with opsd.  If not, see <http://www.gnu.org/licenses/>.

"""Commandline client for communicating with the operations daemon"""

# pylint: disable=invalid-name

import datetime
import json
import os
import sys
import Pyro4
from warwick.observatory.common import daemons
from warwick.observatory.operations import (
    CommandStatus,
    validate_schedule
)

from warwick.rasa.operations import RASAConfig

SCRIPT_NAME = os.path.basename(sys.argv[0])
sys.excepthook = Pyro4.util.excepthook

FMT_GREEN = u'\033[92m'
FMT_RED = u'\033[91m'
FMT_CYAN = u'\033[96m'
FMT_YELLOW = u'\033[93m'
FMT_BOLD = u'\033[1m'
FMT_CLEAR = u'\033[0m'

OPS_MODES = {
    0: FMT_RED + 'ERROR',
    1: FMT_GREEN + 'AUTOMATIC',
    2: FMT_YELLOW + 'MANUAL'
}

DOME_STATUS_CODES = {
    0: FMT_RED + 'CLOSED',
    1: FMT_GREEN + 'OPEN',
    2: FMT_YELLOW + 'MOVING'
}

CONDITIONS = ['wind', 'median_wind', 'temperature', 'humidity', 'internal_humidity', 'dewpt',
              'rain', 'netping', 'ups', 'diskspace', 'sun']

CONDITION_NAMES = {
    'wind': 'Wind',
    'median_wind': 'Median Wind',
    'temperature': 'Temperature',
    'humidity': 'Humidity',
    'internal_humidity': 'Int. Humidity',
    'dewpt': 'Dew Point',
    'rain': 'Rain',
    'netping': 'Network',
    'ups': 'UPS',
    'diskspace': 'Disk Space',
    'sun': 'Sun'
}

CONDITION_STATUS_COLORS = [
    FMT_CYAN, FMT_GREEN, FMT_YELLOW, FMT_RED
]

def run_command(command):
    """Prints the message associated with a status code and returns the code"""
    try:
        ret = command()
    except KeyboardInterrupt:
        # ctrl-c terminates the running command
#        ret = stop()
        ret = 0

        # Report successful stop
        if ret == 0:
            ret = -100
    except Pyro4.errors.CommunicationError:
        ret = -101

    # Print message associated with error codes, except for -1 (error handled locally)
    if ret != -1 and ret != 0:
        print(CommandStatus.message(ret))
    sys.exit(ret)

def dome_control(args):
    """Changes the dome between automatic and manual control and cancels automated observing"""
    if args:
        if args[0] == 'clear':
            with daemons.rasa_operations.connect() as ops:
                return ops.clear_dome_window()

        if args[0] in ['auto', 'manual']:
            with daemons.rasa_operations.connect() as ops:
                return ops.dome_control(args[0] == 'auto')

    print('usage: {} dome (auto|manual|clear)'.format(SCRIPT_NAME))
    return -1

def tel_control(args):
    """Changes the telescope between automatic and manual control and cancels automated observing"""
    if args:
        if args[0] == 'stop':
            with daemons.rasa_operations.connect() as ops:
                return ops.stop_telescope()

        if args[0] in ['auto', 'manual']:
            with daemons.rasa_operations.connect() as ops:
                return ops.tel_control(args[0] == 'auto')

    print('usage: {} tel (auto|manual|stop)'.format(SCRIPT_NAME))
    return -1

def dehumidifier_control(args):
    """Changes the dehumidifier between automatic and manual control"""
    if args:
        if args[0] in ['auto', 'manual']:
            with daemons.rasa_operations.connect() as ops:
                return ops.dehumidifier_control(args[0] == 'auto')

    print('usage: {} dehumidifier (auto|manual)'.format(SCRIPT_NAME))
    return -1

def validate_schedule_json(args):
    """checks a schedule file for errors"""
    if len(args) != 1:
        print('usage: {} schedule <observation json>'.format(SCRIPT_NAME))
        return -1

    try:
        with open(args[0], 'r') as infile:
            schedule = json.load(infile)
    except FileNotFoundError:
        print('error: file ' + args[0] + ' not found')
        return -1
    except Exception as e:
        print('error: invalid json file')
        print('error was: ' + str(e))
        return -1

    valid, errors = validate_schedule(schedule, RASAConfig.get_action_types())
    status = FMT_GREEN + 'PASSED' if valid else FMT_RED + 'FAILED'
    print('Validation ' + FMT_BOLD + status + FMT_CLEAR)
    for e in errors:
        print('   ' + e)

    return -1

def schedule(args):
    """Schedule observations for a nights observing"""
    if len(args) != 1:
        print('usage: {} schedule <observation json>'.format(SCRIPT_NAME))
        return -1

    try:
        with open(args[0], 'r') as infile:
            schedule = json.load(infile)
    except FileNotFoundError:
        print('error: file ' + args[0] + ' not found')
        return -1
    except Exception as e:
        print('error: invalid json file')
        print('error was: ' + str(e))
        return -1

    with daemons.rasa_operations.connect() as ops:
        return ops.schedule_observations(schedule)

    return -1

def print_status():
    """Prints the latest ops data in machine-readable form"""
    status = None
    try:
        with daemons.rasa_operations.connect() as ops:
            status = ops.status()
    except Pyro4.errors.CommunicationError:
        print('error: unable to communicate with the operations daemon')
        return 1

    env_date = datetime.datetime.strptime(status['environment']['updated'], '%Y-%m-%dT%H:%M:%SZ')
    env_status = 'Environment status at ' + FMT_BOLD + env_date.strftime('%H:%M:%S') + FMT_CLEAR \
        + ': '
    if status['environment']['safe']:
        env_status += FMT_BOLD + FMT_GREEN + 'SAFE' + FMT_CLEAR
    else:
        unsafe = [CONDITION_NAMES[c] for c in status['environment']['unsafe_conditions']]
        env_status += FMT_BOLD + FMT_RED + 'NOT SAFE' + FMT_CLEAR + FMT_BOLD + ' [' \
            + ', '.join(unsafe) + ']' + FMT_CLEAR
    print(env_status)

    for c in CONDITIONS:
        print_conditions(c, status['environment']['conditions'][c])
    print()

    dome = status['dome']
    dome_date = datetime.datetime.strptime(dome['status_updated'], '%Y-%m-%dT%H:%M:%SZ')
    print('Dome status at ' + FMT_BOLD + dome_date.strftime('%H:%M:%S') + FMT_CLEAR + ':')

    dome_mode = '    Control: ' + FMT_BOLD + OPS_MODES[dome['mode']] + FMT_CLEAR
    if dome['mode'] != dome['requested_mode']:
        dome_mode += ' (' + FMT_BOLD + OPS_MODES[dome['requested_mode']] + FMT_CLEAR + \
            ' queued)'
    print(dome_mode)

    if dome['mode'] == 1:

        open_str = FMT_YELLOW + 'Not Scheduled'
        if dome['requested_open_date']:
            open_str = dome['requested_open_date']
        print('     Opening: ' + FMT_BOLD + open_str + FMT_CLEAR)

        close_str = FMT_YELLOW + 'Not Scheduled'
        if dome['requested_close_date']:
            close_str = dome['requested_close_date']
        print('     Closing: ' + FMT_BOLD + close_str + FMT_CLEAR)

        dome_status = '    Shutters: ' + FMT_BOLD + DOME_STATUS_CODES[dome['status']] + \
            FMT_CLEAR
        print(dome_status)

    tel = status['telescope']
    tel_date = datetime.datetime.strptime(tel['status_updated'], '%Y-%m-%dT%H:%M:%SZ')
    print('Telescope status at ' + FMT_BOLD + tel_date.strftime('%H:%M:%S') + FMT_CLEAR + ':')

    tel_mode = '    Control: ' + FMT_BOLD + OPS_MODES[tel['mode']] + FMT_CLEAR
    if tel['mode'] != tel['requested_mode']:
        tel_mode += ' (' + FMT_BOLD + OPS_MODES[tel['requested_mode']] + FMT_CLEAR + \
            ' queued)'

    print(tel_mode)

    if 'action_name' in tel:
        name = '       Name: ' + FMT_BOLD + tel['action_name'] + FMT_CLEAR
        
        if tel['action_number'] > 0:
            name += ' (' + str(tel['action_number']) + ' of ' + str(tel['action_count']) + ')'
        print(name)


        if tel['action_task']:
            print('       Task: ' + FMT_BOLD + tel['action_task'] + FMT_CLEAR)
    elif tel['mode'] == 1:
        print('    Action name: ' + FMT_BOLD + 'IDLE' + FMT_CLEAR)


    dehumidifier = status['dehumidifier']
    dehumidifier_date = datetime.datetime.strptime(dehumidifier['active_updated'], '%Y-%m-%dT%H:%M:%SZ')
    print('Dehumidifier status at ' + FMT_BOLD + dehumidifier_date.strftime('%H:%M:%S') + FMT_CLEAR + ':')

    dehumidifier_mode = '    Control: ' + FMT_BOLD + OPS_MODES[dehumidifier['mode']] + FMT_CLEAR
    if dehumidifier['mode'] != dehumidifier['requested_mode']:
        dehumidifier_mode += ' (' + FMT_BOLD + OPS_MODES[dehumidifier['requested_mode']] + \
            FMT_CLEAR + ' queued)'
    print(dehumidifier_mode)

    if dehumidifier['mode'] == 1:
        dehumidifier_active = '     Status: ' + FMT_BOLD
        if dehumidifier['active']:
            dehumidifier_active += FMT_RED + 'ENABLED' + FMT_CLEAR
        else:
            dehumidifier_active += FMT_GREEN + 'DISABLED' + FMT_CLEAR
        print(dehumidifier_active)

    return 0

def print_conditions(condition, params):
    """Prints the status line for a given condition type"""
    print('{:>17}'.format(CONDITION_NAMES[condition]) + ': ' \
        + ', '.join([FMT_BOLD + CONDITION_STATUS_COLORS[p[1]] + p[0] + FMT_CLEAR for p in params]))

def print_json():
    """Prints the latest ops data in machine-readable form"""
    status = None
    try:
        with daemons.rasa_operations.connect() as ops:
            status = ops.status()
    except Pyro4.errors.CommunicationError:
        print('error: unable to communicate with the operations daemon')
        return 1

    print(json.dumps(status))

    return 0

def print_usage(name):
    """Prints the utility help"""
    print('Usage: {} <command>'.format(name))
    print()
    print('   json         print a machine-readable summary of the operations status')
    print('   status       print a human-readable summary of the operations status')
    print('   dome         toggle dome between manual and automatic control or clear schedule')
    print('   tel          toggle telescope between manual and automatic control or cancel actions')
    print('   dehumidifier toggle dehumidifier between manual and automatic control')
    print('   validate     checks a schedule file for errors')
    print('   schedule     schedule observations for the night')
    print()

    return 1

if __name__ == '__main__':
    if len(sys.argv) == 1:
        sys.exit(print_usage(SCRIPT_NAME))

    if sys.argv[1] == 'status':
        sys.exit(print_status())
    elif sys.argv[1] == 'json':
        sys.exit(print_json())
    elif sys.argv[1] == 'dome':
        run_command(lambda: dome_control(sys.argv[2:]))
    elif sys.argv[1] == 'tel':
        run_command(lambda: tel_control(sys.argv[2:]))
    elif sys.argv[1] == 'dehumidifier':
        run_command(lambda: dehumidifier_control(sys.argv[2:]))
    elif sys.argv[1] == 'validate':
        run_command(lambda: validate_schedule_json(sys.argv[2:]))
    elif sys.argv[1] == 'schedule':
        run_command(lambda: schedule(sys.argv[2:]))

    # Command not found
    sys.exit(print_usage(SCRIPT_NAME))
