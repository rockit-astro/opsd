#!/usr/bin/env python3
#
# This file is part of opsd.
#
# opsd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# opsd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with opsd.  If not, see <http://www.gnu.org/licenses/>.

"""Simplified commandline client for Windmill Hill"""

import os
import sys
import time
import Pyro4
from astropy.time import Time
from warwick.observatory.common import daemons, TFmt
from warwick.observatory.operations import CommandStatus, ConditionStatus, DomeStatus, OperationsMode
from warwick.observatory.ashdome import AzimuthStatus, HeartbeatStatus, CommandStatus as DomeCommandStatus

SCRIPT_NAME = os.path.basename(sys.argv[0])

sys.excepthook = Pyro4.util.excepthook


def run_command(command, args):
    """Runs a daemon command, handling error messages"""
    try:
        ret = command(daemons.warwick_operations, args)
    except Pyro4.errors.CommunicationError:
        ret = -101

    # Print message associated with error codes, except for -1 (error handled locally)
    if ret not in (0, -1):
        print(CommandStatus.message(ret))
    return ret


def start(daemon, _):
    """Enable automatic dome control"""
    # Check if the dome is ready first!
    with daemons.warwick_dome.connect(timeout=10) as dome:
        status = dome.status()
        if status['azimuth_status'] == AzimuthStatus.Disconnected:
            ret = dome.initialize()
            if ret != DomeCommandStatus.Succeeded:
                print('error: failed to initialize dome. Is it powered on?')
                return 1

            status = dome.status()

        # Reset heartbeat status
        if status['heartbeat_status'] in [HeartbeatStatus.TrippedIdle, HeartbeatStatus.TrippedClosing]:
            ret = dome.set_heartbeat_timer(0)
            if ret != DomeCommandStatus.Succeeded:
                print('error: failed to reset heartbeat.')
                return 1

    if status == AzimuthStatus.NotHomed:
        with daemons.warwick_dome.connect(timeout=0) as dome:
            ret = dome.home_azimuth()
            if ret != DomeCommandStatus.Succeeded:
                print('error: failed to home dome.')
                return 1

    with daemon.connect(timeout=30) as ops:
        status = ops.status()
        if status['dome']['mode'] != OperationsMode.Automatic:
            ret = ops.dome_control(True)
            if ret != CommandStatus.Succeeded:
                return ret

        if status['telescope']['mode'] != OperationsMode.Automatic:
            ret = ops.tel_control(True)
            if ret != CommandStatus.Succeeded:
                return ret

        ret = ops.schedule_observations({
            'night': ops.current_night(),
            'dome': {
                'open': 'auto',
                'close': 'auto'
            },
            'actions': []
        })

        if ret != CommandStatus.Succeeded:
            return ret

        status = ops.status()
    print_dome(status)
    return CommandStatus.Succeeded


def stop(daemon, _):
    """Disable automatic dome control"""
    with daemon.connect() as ops:
        ret = ops.clear_dome_window()
        if ret != CommandStatus.Succeeded:
            return ret

        status = ops.status()

    if status['dome']['status'] != DomeStatus.Closed:
        print('waiting for dome to close...')

    # Wait for dome to close
    while True:
        with daemon.connect() as ops:
            status = ops.status()
            if status['dome']['status'] == DomeStatus.Closed:
                break
        time.sleep(0.5)

    with daemon.connect(timeout=10) as ops:
        ops.tel_control(False)
        ret = ops.dome_control(False)
        if ret != CommandStatus.Succeeded:
            return ret

        status = ops.status()
    print_dome(status)
    return CommandStatus.Succeeded

def print_environment(status):
    env_date = Time.strptime(status['environment']['updated'], '%Y-%m-%dT%H:%M:%SZ')
    print('Environment status at ' + TFmt.Bold + env_date.strftime('%H:%M:%S') + TFmt.Clear + ':')

    for label, sensors in status['environment']['conditions'].items():
        line = '{:>17}'.format(label) + ': '
        line += ', '.join([ConditionStatus.label(s, True) for s in sensors.values()])
        print(line)


def print_dome(status):
    dome = status['dome']
    dome_date = Time.strptime(dome['status_updated'], '%Y-%m-%dT%H:%M:%SZ')
    print('Dome status at ' + TFmt.Bold + dome_date.strftime('%H:%M:%S') + TFmt.Clear + ':')

    print('    Control: ' + OperationsMode.label(dome['mode'], True))

    if dome['mode'] == OperationsMode.Automatic:
        open_str = TFmt.Yellow + 'Not Scheduled'
        if dome['open_date']:
            open_str = dome['open_date']
        print('    Opening: ' + TFmt.Bold + open_str + TFmt.Clear)

        close_str = TFmt.Yellow + 'Not Scheduled'
        if dome['close_date']:
            close_str = dome['close_date']
        print('    Closing: ' + TFmt.Bold + close_str + TFmt.Clear)

        dome_status = '    Shutter: ' + DomeStatus.label(dome['status'], True)
        print(dome_status)


def print_status(daemon, _):
    """Prints the latest ops data in machine-readable form"""
    with daemon.connect() as ops:
        status = ops.status()

    print_environment(status)
    print()
    print_dome(status)
    return 0


def print_usage():
    """Prints the utility help"""
    print('Usage: {} <command>'.format(SCRIPT_NAME))
    print()
    print('   start       enable automated dome control')
    print('   stop        disable automated dome control')
    print('   status      print a human-readable status summary')
    print()

    return 1


if __name__ == '__main__':
    commands = {
        'status': print_status,
        'start': start,
        'stop': stop,
    }

    if len(sys.argv) >= 2 and sys.argv[1] in commands:
        sys.exit(run_command(commands[sys.argv[1]], sys.argv[2:]))

    sys.exit(print_usage())
