#!/usr/bin/env python3
#
# This file is part of opsd.
#
# opsd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# opsd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with opsd.  If not, see <http://www.gnu.org/licenses/>.

"""Operations daemon for the Warwick one-metre telescope"""

# pylint: disable=invalid-name
# pylint: disable=broad-except
# pylint: disable=too-many-instance-attributes

import datetime
import sys
import threading
from astropy import units as u
import Pyro4
from warwick.observatory.common import (
    daemons,
    log,
    TryLock)

from warwick.w1m.operations import (
    DomeController,
    DomeStatus,
    TelescopeController,
    CommandStatus,
    OperationsMode,
    DehumidifierMode
)

from warwick.w1m.environment import (
    ParameterStatus
)

# Include more detailed exceptions
sys.excepthook = Pyro4.util.excepthook

# Communications timeout when opening or closing the dome (takes up to ~80 seconds)
DOME_PYRO_OPENCLOSE_TIMEOUT = 120

# Delay between ops and dome loop ticks (seconds)
LOOP_DELAY = 10

# Timeout period (seconds) for the dome controller
# The dome heartbeat is pinged once per LOOP_DELAY when the dome is under
# automatic control and is fully open or fully closed.  This timeout should
# be large enough to account for the time it takes to open and close the dome
DOME_HEARTBEAT_TIMEOUT = 119

# Humidity limits for automatic dehumidifier control
DEHUMIDIFIER_CONFIG = {
    'enable_above': 75,
    'disable_below': 70
}

AUTOFLAT_CONFIG = {
    # Exposure fudge factor to account for changing sky brightness
    'evening_scale': 1.1,
    'dawn_scale': 0.9,

    # Clamp exposure time deltas to this range (e.g. 5 -> 15 or 5 -> 1.6)
    'max_exposure_delta': 3,

    # Exposure limits in seconds
    'min_exposure': 0.1,
    'max_exposure': 30,

    # Exposures shorter than this will have large shutter effects and will be discarded
    'min_save_exposure': 2.5,

    # Exposures with less counts than this lack the signal to noise ratio that we desire
    'min_save_counts': 20000,

    # Target flat counts to aim for
    'target_counts': 35000,

    # Delays to apply between evening flats to save shutter cycles
    # These delays are cumulative, so if the next exposure is calculated to be 0.9
    # 0.9 seconds the routine will wait 5 + 25 = 30 seconds before starting it
    'evening_exposure_delays': {
        1: 25,
        2.5: 5
    }
}

AUTOACQUIRE_CONFIG = {
    'exposure_length': 10,

    # Additional maximum wait time for readout + pipeline processing
    'max_readout_process_time': 15,

    # Aim for an accuracy of 1 arcsec
    'pointing_threshold': 1.0,

    # Number of attempts before we give up
    'adjust_attempts': 5,
    'wcs_attempts': 3,

    # Offset in radians to transform red camera coordinates to blue camera coordinates
    # pylint: disable=no-member
    'red_camera_offset': (2.043859e-4 * u.radian, 4.899995e-6 * u.radian),
    # pylint: enable=no-member

    'slew_timeout': 60,
}


def environment_latest(device, sensor, max_age):
    """Returns the latest value of an environment sensor if it is recent enough, or None"""
    date = datetime.datetime.strptime(device['measurement_end'], '%Y-%m-%dT%H:%M:%SZ')
    if sensor in device['data'] and datetime.datetime.utcnow() - date < max_age:
        return device['data'][sensor]['latest']
    return None

class OperationsDaemon:
    """Daemon class that controls the overall observatory operations"""
    def __init__(self):
        self._command_lock = threading.Lock()
        self._wait_condition = threading.Condition()
        self._observing = False

        self._dome = DomeController(
            daemons.onemetre_dome,
            DOME_PYRO_OPENCLOSE_TIMEOUT,
            DOME_HEARTBEAT_TIMEOUT,
            LOOP_DELAY)

        self._telescope = TelescopeController(AUTOFLAT_CONFIG, AUTOACQUIRE_CONFIG)

        # environment state - take the lock before writing or reading coherant state!
        self._environment_lock = threading.Lock()
        self._environment_updated = datetime.datetime.utcnow()
        self._environment_safe = False

        self._dehumidifier_mode = DehumidifierMode.Manual
        self._dehumidifier_active = False
        self._dehumidifier_error = False

        runloop = threading.Thread(target=self.__ops_loop)
        runloop.daemon = True
        runloop.start()

    def __update_dehumidifier(self, env):
        # Use external sensors if internal humidity isn't available
        age = datetime.timedelta(seconds=30)
        humidity = environment_latest(env['roomalert'], 'internal_humidity', age) or \
            environment_latest(env['vaisala'], 'relative_humidity', age) or \
            environment_latest(env['superwasp'], 'ext_humidity', age)

        # Implement hysteresis to avoid flickering on/off when humidity is on thelimit
        limit = 'disable_below' if self._dehumidifier_active else 'enable_above'
        active = humidity > DEHUMIDIFIER_CONFIG[limit]

        if active != self._dehumidifier_active:
            if active:
                log.warning('opsd', 'Dehumidifier enabled (humidity: {}% > {}%)'.format(
                    humidity, DEHUMIDIFIER_CONFIG[limit]))
            else:
                log.info('opsd', 'Dehumidifier disabled (humidity: {}% < {}%)'.format(
                    humidity, DEHUMIDIFIER_CONFIG[limit]))

        self._dehumidifier_active = active
        try:
            with daemons.onemetre_power.connect() as power:
                active = power.value('dehumidifier')
                if active != self._dehumidifier_active:
                    success = power.switch('dehumidifier', self._dehumidifier_active)
                    if not success:
                        raise Exception('Failed to switch dehumidifier')

            if self._dehumidifier_error:
                log.info('opsd', 'Restored contact with dehumidifier')
                self._dehumidifier_error = False
        except Exception as e:
            print('error: failed to update dehumidifier: ', e)
            if not self._dehumidifier_error:
                log.error('opsd', 'Lost contact with dehumidifier')
            self._dehumidifier_error = True

    def __ops_loop(self):
        """Main operations run loop."""
        environment_safe = False
        while True:
            was_safe = environment_safe
            try:
                with daemons.onemetre_environment.connect() as environment:
                    environment_status = environment.status()

                environment_safe = not any(environment_status[sensor]['status'] == \
                    ParameterStatus.Unsafe for sensor in environment_status)

                if was_safe and not environment_safe:
                    log.warning('opsd', 'Environment has become unsafe')
                elif not was_safe and environment_safe:
                    log.info('opsd', 'Environment trigger timed out')
            except Exception as e:
                environment_safe = False
                print('error: failed to query environment: ', e)
                log.info('opsd', 'Failed to query environmentd (' + str(e) + ')')

            with self._environment_lock:
                self._environment_safe = environment_safe
                self._environment_updated = datetime.datetime.utcnow()

            dome_status = self._dome.status()
            if dome_status['mode'] == OperationsMode.Error:
                self._observing = False
                print('Observing condition disabled (dome error)')
                log.warning('opsd', 'Observing condition disabled (dome error)')

            if not environment_safe and self._observing:
                self._observing = False
                unsafe_params = [sensor for sensor in environment_status
                                 if environment_status[sensor]['status'] == ParameterStatus.Unsafe]
                print('Observing condition disabled (environment: '
                      + ', '.join(unsafe_params) + ')')
                log.warning('opsd', 'Observing condition disabled (environment: '
                            + ', '.join(unsafe_params) + ')')

            self._dome.request_status(DomeStatus.Open if self._observing else DomeStatus.Closed)

            if self._dehumidifier_mode == DehumidifierMode.Automatic:
                self.__update_dehumidifier(environment_status)
            else:
                self._dehumidifier_active = False

            # Wait for the next loop period, unless woken up early by __shortcut_loop_wait
            with self._wait_condition:
                self._wait_condition.wait(LOOP_DELAY)

    def __shortcut_loop_wait(self):
        """Makes the run loop continue immediately if it is currently sleeping"""
        with self._wait_condition:
            self._wait_condition.notify_all()

    @Pyro4.expose
    def dome_control(self, automatic):
        """Switch the dome between manual (observer) and automatic (opsd) control"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # Require dome to be fully closed or open before switching to automatic
            dome_status = self._dome.status()
            if automatic and dome_status['mode'] == OperationsMode.Error:
                return CommandStatus.InErrorState

            mode = OperationsMode.Automatic if automatic else OperationsMode.Manual
            self._dome.request_mode(mode)

            log.info('opsd', 'Dome control manually changed to '
                     + ('automatic' if automatic else 'manual'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def dehumidifier_control(self, mode):
        """Enable or disable automatic dehumidifier control"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            self._dehumidifier_mode = mode
            self.__shortcut_loop_wait()
            log.info('opsd', 'Dehumidifier control set to '
                     + ('automatic' if mode == DehumidifierMode.Automatic else 'manual'))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_observing(self, observing):
        """Enable or disable the global observing mode (opens the dome)"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            dome_status = self._dome.status()
            if observing and dome_status['mode'] == OperationsMode.Error:
                return CommandStatus.InErrorState

            self._observing = observing
            self.__shortcut_loop_wait()
            log.info('opsd', 'Observing condition manually '
                     + ('enabled' if observing else 'disabled'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def status(self):
        """Query the latest status."""
        data = {
            'observing': self._observing,
            'dehumidifier': {
                'mode': self._dehumidifier_mode,
                'active': self._dehumidifier_active
            },
            'dome': self._dome.status()
        }

        with self._environment_lock:
            data.update({
                'environment_safe': self._environment_safe,
                'environment_updated': self._environment_updated.strftime('%Y-%m-%dT%H:%M:%SZ')
            })

        return data

    @Pyro4.expose
    def notify_processed_frame(self, headers):
        """Called by the pipeline daemon to notify that a new frame has completed processing
           headers is a dictionary holding the key-value pairs from the fits header"""
        self._telescope.notify_processed_frame(headers)

    @Pyro4.expose
    def autoflat(self):
        """Automatically runs the cameras (and eventually the telescope) to acquire flat frames"""
        return self._telescope.autoflat()

    @Pyro4.expose
    def acquire_field(self, ra_radians, dec_radians):
        """Automatically home in on a target position"""
        return self._telescope.acquire_field(ra_radians, dec_radians)

    @Pyro4.expose
    def stop_telescope(self):
        """Cancels an active telescope task"""
        return self._telescope.stop()

if __name__ == '__main__':
    daemons.onemetre_operations.launch(OperationsDaemon())
