#!/usr/bin/env python3.4
#
# This file is part of opsd.
#
# opsd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# opsd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with opsd.  If not, see <http://www.gnu.org/licenses/>.

"""Operations daemon for the Warwick one-metre telescope"""

# pylint: disable=invalid-name
# pylint: disable=broad-except
# pylint: disable=too-many-instance-attributes

import sys
import threading
import Pyro4
from warwick.observatory.common import (
    daemons,
    log,
    IP,
    TryLock)
from warwick.observatory.common.helpers import pyro_client_matches
from warwick.rasa.operations import (
    DomeController,
    TelescopeController,
    EnvironmentWatcher,
    CommandStatus,
    OperationsMode,
    parse_dome_window,
    parse_schedule_actions,
    validate_schedule,
)

# Include more detailed exceptions
sys.excepthook = Pyro4.util.excepthook

# Machines that are allowed to issue operations commands
CONTROL_IPS = [IP.RASAMain]

# Machines that are allowed to notify processed frames
PROCESSED_FRAME_IPS = [IP.RASAMain]

# Communications timeout when opening or closing the dome (takes up to ~80 seconds)
DOME_PYRO_OPENCLOSE_TIMEOUT = 120

# Delay between ops and dome loop ticks (seconds)
LOOP_DELAY = 10

# Timeout period (seconds) for the dome controller
# The dome heartbeat is pinged once per LOOP_DELAY when the dome is under
# automatic control and is fully open or fully closed.  This timeout should
# be large enough to account for the time it takes to open and close the dome
DOME_HEARTBEAT_TIMEOUT = 119

class OperationsDaemon:
    """Daemon class that controls the overall observatory operations"""
    def __init__(self):
        self._command_lock = threading.Lock()
        self._wait_condition = threading.Condition()

        self._dome = DomeController(
            daemons.rasa_dome,
            DOME_PYRO_OPENCLOSE_TIMEOUT,
            DOME_HEARTBEAT_TIMEOUT,
            LOOP_DELAY)

        self._telescope = TelescopeController()
        self._environment = EnvironmentWatcher()

        runloop = threading.Thread(target=self.__ops_loop)
        runloop.daemon = True
        runloop.start()

    def __ops_loop(self):
        """Main operations run loop.
           Polls the environment and closes the dome if necessary
           Individual telescope actions are expected to check the
           status of the dome and abort if necessary
        """
        while True:
            self._environment.update()

            dome_status = self._dome.status()
            if not self._environment.safe and self._dome.active():
                self._dome.clear_open_window()
                print('Cancelling dome schedule (environment: '
                      + ', '.join(self._environment.unsafe_conditions) + ')')
                log.warning('rasa_opsd', 'Cancelling dome schedule (environment: '
                            + ', '.join(self._environment.unsafe_conditions) + ')')

            # Wait for the next loop period, unless woken up early by __shortcut_loop_wait
            with self._wait_condition:
                self._wait_condition.wait(LOOP_DELAY)

    def __shortcut_loop_wait(self):
        """Makes the run loop continue immediately if it is currently sleeping"""
        with self._wait_condition:
            self._wait_condition.notify_all()

    @Pyro4.expose
    def dome_control(self, automatic):
        """Switch the dome between manual (observer) and automatic (opsd) control"""
        if not pyro_client_matches(CONTROL_IPS):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # Require dome to be fully closed or open before switching to automatic
            dome_status = self._dome.status()
            if automatic and dome_status['mode'] == OperationsMode.Error:
                return CommandStatus.InErrorState

            mode = OperationsMode.Automatic if automatic else OperationsMode.Manual
            self._dome.request_mode(mode)

            log.info('rasa_opsd', 'Dome control manually changed to '
                     + ('automatic' if automatic else 'manual'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def tel_control(self, automatic):
        """Switch the telescope between manual (observer) and automatic (opsd) control"""
        if not pyro_client_matches(CONTROL_IPS):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # Require error states to be cleared manually before allowing return to automatic mode
            tel_status = self._telescope.status()
            if automatic and tel_status['mode'] == OperationsMode.Error:
                return CommandStatus.InErrorState

            mode = OperationsMode.Automatic if automatic else OperationsMode.Manual
            self._telescope.request_mode(mode)

            log.info('rasa_opsd', 'Telescope control manually changed to '
                     + ('automatic' if automatic else 'manual'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def status(self):
        """Query the latest status."""
        return {
            'dome': self._dome.status(),
            'telescope': self._telescope.status(),
            'environment': self._environment.status()
        }

    @Pyro4.expose
    def notify_processed_frame(self, headers):
        """Called by the pipeline daemon to notify that a new frame has completed processing
           headers is a dictionary holding the key-value pairs from the fits header"""
        if not pyro_client_matches(PROCESSED_FRAME_IPS):
            return

        self._telescope.notify_processed_frame(headers)

    @Pyro4.expose
    def stop_telescope(self):
        """Cancels an active telescope task"""
        if not pyro_client_matches(CONTROL_IPS):
            return CommandStatus.InvalidControlIP

        self._telescope.abort()
        return CommandStatus.Succeeded

    @Pyro4.expose
    def clear_dome_window(self):
        """Cancels the dome open window"""
        if not pyro_client_matches(CONTROL_IPS):
            return CommandStatus.InvalidControlIP

        self._dome.clear_open_window()
        return CommandStatus.Succeeded

    @Pyro4.expose
    def schedule_observations(self, schedule):
        """Schedules actions to the telescope and dome"""
        if not pyro_client_matches(CONTROL_IPS):
            return CommandStatus.InvalidControlIP

        dome_status = self._dome.status()
        if dome_status['mode'] == OperationsMode.Error:
            return CommandStatus.InErrorState

        valid, _ = validate_schedule(schedule)
        if not valid:
            return CommandStatus.InvalidSchedule

        dome_window = parse_dome_window(schedule)
        if dome_window and not self._dome.set_open_window(dome_window):
            return CommandStatus.Failed

        if not self._telescope.queue_actions(parse_schedule_actions(schedule)):
            return CommandStatus.Failed

        self.__shortcut_loop_wait()
        return CommandStatus.Succeeded

if __name__ == '__main__':
    daemons.rasa_operations.launch(OperationsDaemon())
