#!/usr/bin/env python3.6
#
# This file is part of opsd.
#
# opsd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# opsd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with opsd.  If not, see <http://www.gnu.org/licenses/>.

"""Operations daemon for the Warwick one-metre telescope"""

# pylint: disable=invalid-name
# pylint: disable=broad-except
# pylint: disable=too-many-instance-attributes

import argparse
import sys
import threading
import Pyro4
from warwick.observatory.common import log, TryLock
from warwick.observatory.common.helpers import pyro_client_matches
from warwick.observatory.operations import (
    DomeController,
    DomeStatus,
    TelescopeController,
    DehumidifierController,
    EnvironmentWatcher,
    CommandStatus,
    OperationsMode,
    parse_dome_window,
    parse_schedule_actions,
    validate_schedule,
)

# Include more detailed exceptions
sys.excepthook = Pyro4.util.excepthook

# Delay between ops and dome loop ticks (seconds)
LOOP_DELAY = 10

class OperationsDaemon:
    """Daemon class that controls the overall observatory operations"""
    def __init__(self, config):
        self._command_lock = threading.Lock()
        self._wait_condition = threading.Condition()
        self._config = config

        self._dome = DomeController(
            self._config.dome_daemon,
            self._config.log_name,
            self._config.dome_pyro_openclose_timeout,
            self._config.dome_heartbeat_timeout,
            LOOP_DELAY)

        self._telescope = TelescopeController(
            self._config.log_name,
            self._dome,
            self._config.telescope_initialize_action,
            self._config.telescope_park_action)

        self._environment = EnvironmentWatcher(
            self._config.log_name,
            self._config.get_environment_conditions())

        self._dehumidifier = DehumidifierController(
            self._config.power_daemon,
            self._config.log_name)

        runloop = threading.Thread(target=self.__ops_loop)
        runloop.daemon = True
        runloop.start()

    def __ops_loop(self):
        """Main operations run loop.
           Polls the environment and closes the dome if necessary
           Individual telescope actions are expected to check the
           status of the dome and abort if necessary
        """
        while True:
            self._environment.update()
            self._dome.notify_environment_status(self._environment.safe)

            self._dehumidifier.notify_environment_status(
                self._environment.internal_humidity,
                self._environment.external_humidity,
                self._dome.status()['status'] == DomeStatus.Open)

            # Wait for the next loop period, unless woken up early by __shortcut_loop_wait
            with self._wait_condition:
                self._wait_condition.wait(LOOP_DELAY)

    def __shortcut_loop_wait(self):
        """Makes the run loop continue immediately if it is currently sleeping"""
        with self._wait_condition:
            self._wait_condition.notify_all()

    @Pyro4.expose
    def dome_control(self, automatic):
        """Switch the dome between manual (observer) and automatic (opsd) control"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # Require dome to be fully closed or open before switching to automatic
            dome_status = self._dome.status()
            if automatic and dome_status['mode'] == OperationsMode.Error:
                return CommandStatus.InErrorState

            mode = OperationsMode.Automatic if automatic else OperationsMode.Manual
            self._dome.request_mode(mode)

            log.info(self._config.log_name, 'Dome control changed to '
                     + ('automatic' if automatic else 'manual'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def tel_control(self, automatic):
        """Switch the telescope between manual (observer) and automatic (opsd) control"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # Require error states to be cleared manually before allowing return to automatic mode
            tel_status = self._telescope.status()
            if automatic and tel_status['mode'] == OperationsMode.Error:
                return CommandStatus.InErrorState

            mode = OperationsMode.Automatic if automatic else OperationsMode.Manual
            self._telescope.request_mode(mode)

            log.info(self._config.log_name, 'Telescope control changed to '
                     + ('automatic' if automatic else 'manual'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def dehumidifier_control(self, automatic):
        """Switch the dehumidifier between manual (observer) and automatic (opsd) control"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            mode = OperationsMode.Automatic if automatic else OperationsMode.Manual
            self._dehumidifier.request_mode(mode)

            log.info(self._config.log_name, 'Dehumidifier control changed to '
                     + ('automatic' if automatic else 'manual'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def status(self):
        """Query the latest status."""
        return {
            'dome': self._dome.status(),
            'telescope': self._telescope.status(),
            'environment': self._environment.status(),
            'dehumidifier': self._dehumidifier.status(),
        }

    @Pyro4.expose
    def notify_processed_frame(self, headers):
        """Called by the pipeline daemon to notify that a new frame has completed processing
           headers is a dictionary holding the key-value pairs from the fits header"""
        if not pyro_client_matches(self._config.processed_frame_ips):
            return

        self._telescope.notify_processed_frame(headers)

    @Pyro4.expose
    def stop_telescope(self):
        """Cancels an active telescope task"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        self._telescope.abort()
        return CommandStatus.Succeeded

    @Pyro4.expose
    def clear_dome_window(self):
        """Cancels the dome open window"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        self._dome.clear_open_window()
        return CommandStatus.Succeeded

    @Pyro4.expose
    def schedule_observations(self, schedule):
        """Schedules actions to the telescope and dome"""
        if not pyro_client_matches(self._config.control_ips):
            return CommandStatus.InvalidControlIP

        dome_status = self._dome.status()
        if dome_status['mode'] == OperationsMode.Error:
            return CommandStatus.InErrorState

        valid, _ = validate_schedule(schedule, self._config.get_action_types())
        if not valid:
            return CommandStatus.InvalidSchedule

        dome_window = parse_dome_window(schedule)
        if dome_window and not self._dome.set_open_window(dome_window):
            return CommandStatus.Failed

        if not self._telescope.queue_actions(parse_schedule_actions(
                schedule, self._config.get_action_types())):
            return CommandStatus.Failed

        self.__shortcut_loop_wait()
        return CommandStatus.Succeeded

if __name__ == '__main__':
    description = 'Operations Control'
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('telescope', choices=['onemetre', 'rasa'], help='Select a telescope')
    args = parser.parse_args()

    # TODO: Clean this up properly
    if args.telescope == 'rasa':
        from warwick.rasa.operations import RASAConfig
        config = RASAConfig
    else:
        from warwick.w1m.operations import OneMetreConfig
        config = OneMetreConfig

    config.ops_daemon.launch(OperationsDaemon(config))
