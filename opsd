#!/usr/bin/env python3.4
#
# This file is part of opsd.
#
# opsd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# opsd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with opsd.  If not, see <http://www.gnu.org/licenses/>.

"""Operations daemon for the Warwick one-metre telescope"""

# pylint: disable=invalid-name
# pylint: disable=broad-except
# pylint: disable=too-many-instance-attributes

import sys
import threading
import Pyro4
from warwick.observatory.common import (
    daemons,
    log,
    IP,
    TryLock)
from warwick.observatory.common.helpers import pyro_client_matches
from warwick.w1m.operations import (
    DomeController,
    DomeStatus,
    TelescopeController,
    EnvironmentWatcher,
    CommandStatus,
    OperationsMode,
    DehumidifierMode,
    parse_schedule_actions,
    validate_schedule,
)

from warwick.w1m.power import SwitchStatus

# Include more detailed exceptions
sys.excepthook = Pyro4.util.excepthook

# Machines that are allowed to issue operations commands
CONTROL_IPS = [IP.OneMetreDome, IP.OneMetreTCS]

# Machines that are allowed to notify processed frames
PROCESSED_FRAME_IPS = [IP.OneMetreTCS]

# Communications timeout when opening or closing the dome (takes up to ~80 seconds)
DOME_PYRO_OPENCLOSE_TIMEOUT = 120

# Delay between ops and dome loop ticks (seconds)
LOOP_DELAY = 10

# Timeout period (seconds) for the dome controller
# The dome heartbeat is pinged once per LOOP_DELAY when the dome is under
# automatic control and is fully open or fully closed.  This timeout should
# be large enough to account for the time it takes to open and close the dome
DOME_HEARTBEAT_TIMEOUT = 119

# Humidity limits for automatic dehumidifier control
DEHUMIDIFIER_CONFIG = {
    'enable_above': 70,
    'disable_below': 65
}

class OperationsDaemon:
    """Daemon class that controls the overall observatory operations"""
    def __init__(self):
        self._command_lock = threading.Lock()
        self._wait_condition = threading.Condition()
        self._observing = False

        self._dome = DomeController(
            daemons.onemetre_dome,
            DOME_PYRO_OPENCLOSE_TIMEOUT,
            DOME_HEARTBEAT_TIMEOUT,
            LOOP_DELAY)

        self._telescope = TelescopeController()
        self._environment = EnvironmentWatcher()

        self._dehumidifier_mode = DehumidifierMode.Automatic
        self._dehumidifier_active = False
        self._dehumidifier_error = False
        self._dehumidifier_humidity_error = True

        runloop = threading.Thread(target=self.__ops_loop)
        runloop.daemon = True
        runloop.start()

    def __update_dehumidifier(self):
        # Use external sensors if internal humidity isn't available
        humidity = self._environment.internal_humidity or self._environment.external_humidity

        if humidity is None:
            if not self._dehumidifier_humidity_error:
                log.warning('opsd', 'Lost contact with all humidity sensors')
                self._dehumidifier_humidity_error = True

            # Can't do anything more without valid humidity data
            return

        if self._dehumidifier_humidity_error:
            log.info('opsd', 'Restored contact with humidity sensor')
            self._dehumidifier_humidity_error = False

        # Implement hysteresis to avoid flickering on/off when humidity is on the limit
        # Also force-disable when the observing condition is set
        limit = 'disable_below' if self._dehumidifier_active else 'enable_above'
        active = not self._observing and humidity > DEHUMIDIFIER_CONFIG[limit]

        if active != self._dehumidifier_active:
            if active:
                log.warning('opsd', 'Dehumidifier enabled (humidity: {}% > {}%)'.format(
                    humidity, DEHUMIDIFIER_CONFIG[limit]))
            else:
                log.info('opsd', 'Dehumidifier disabled (humidity: {}% < {}%)'.format(
                    humidity, DEHUMIDIFIER_CONFIG[limit]))

        self._dehumidifier_active = active
        try:
            with daemons.onemetre_power.connect() as power:
                dehumidifier_power = power.value('dehumidifier')
                if dehumidifier_power == SwitchStatus.Unknown:
                    raise Exception("Dehumidifier status unknown")

                if (dehumidifier_power == SwitchStatus.On) != self._dehumidifier_active:
                    success = power.switch('dehumidifier', self._dehumidifier_active)
                    if not success:
                        raise Exception('Failed to switch dehumidifier')

            if self._dehumidifier_error:
                log.info('opsd', 'Restored contact with dehumidifier')
                self._dehumidifier_error = False
        except Exception as e:
            print('error: failed to update dehumidifier: ', e)
            if not self._dehumidifier_error:
                log.error('opsd', 'Lost contact with dehumidifier')
            self._dehumidifier_error = True

    def __ops_loop(self):
        """Main operations run loop."""
        while True:
            self._environment.update()

            dome_status = self._dome.status()
            if dome_status['mode'] == OperationsMode.Error:
                self._observing = False
                print('Observing condition disabled (dome error)')
                log.warning('opsd', 'Observing condition disabled (dome error)')

            if not self._environment.safe and self._observing:
                self._observing = False
                print('Observing condition disabled (environment: '
                      + ', '.join(self._environment.unsafe_conditions) + ')')
                log.warning('opsd', 'Observing condition disabled (environment: '
                            + ', '.join(self._environment.unsafe_conditions) + ')')

            self._dome.request_status(DomeStatus.Open if self._observing else DomeStatus.Closed)

            if self._dehumidifier_mode == DehumidifierMode.Automatic:
                self.__update_dehumidifier()
            else:
                self._dehumidifier_active = False

            # Wait for the next loop period, unless woken up early by __shortcut_loop_wait
            with self._wait_condition:
                self._wait_condition.wait(LOOP_DELAY)

    def __shortcut_loop_wait(self):
        """Makes the run loop continue immediately if it is currently sleeping"""
        with self._wait_condition:
            self._wait_condition.notify_all()

    @Pyro4.expose
    def dome_control(self, automatic):
        """Switch the dome between manual (observer) and automatic (opsd) control"""
        if not pyro_client_matches(CONTROL_IPS):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # Require dome to be fully closed or open before switching to automatic
            dome_status = self._dome.status()
            if automatic and dome_status['mode'] == OperationsMode.Error:
                return CommandStatus.InErrorState

            mode = OperationsMode.Automatic if automatic else OperationsMode.Manual
            self._dome.request_mode(mode)

            log.info('opsd', 'Dome control manually changed to '
                     + ('automatic' if automatic else 'manual'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def tel_control(self, automatic):
        """Switch the telescope between manual (observer) and automatic (opsd) control"""
        if not pyro_client_matches(CONTROL_IPS):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # Require error states to be cleared manually before allowing return to automatic mode
            tel_status = self._telescope.status()
            if automatic and tel_status['mode'] == OperationsMode.Error:
                return CommandStatus.InErrorState

            mode = OperationsMode.Automatic if automatic else OperationsMode.Manual
            self._telescope.request_mode(mode)

            log.info('opsd', 'Telescope control manually changed to '
                     + ('automatic' if automatic else 'manual'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def dehumidifier_control(self, mode):
        """Enable or disable automatic dehumidifier control"""
        if not pyro_client_matches(CONTROL_IPS):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            self._dehumidifier_mode = mode
            self.__shortcut_loop_wait()
            log.info('opsd', 'Dehumidifier control set to '
                     + ('automatic' if mode == DehumidifierMode.Automatic else 'manual'))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_observing(self, observing):
        """Enable or disable the global observing mode (opens the dome)"""
        if not pyro_client_matches(CONTROL_IPS):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            dome_status = self._dome.status()
            if observing and dome_status['mode'] == OperationsMode.Error:
                return CommandStatus.InErrorState

            self._observing = observing
            self.__shortcut_loop_wait()
            log.info('opsd', 'Observing condition manually '
                     + ('enabled' if observing else 'disabled'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def status(self):
        """Query the latest status."""
        return {
            'observing': self._observing,
            'dehumidifier': {
                'mode': self._dehumidifier_mode,
                'active': self._dehumidifier_active
            },
            'dome': self._dome.status(),
            'telescope': self._telescope.status(),
            'environment': self._environment.status()
        }

    @Pyro4.expose
    def notify_processed_frame(self, headers):
        """Called by the pipeline daemon to notify that a new frame has completed processing
           headers is a dictionary holding the key-value pairs from the fits header"""
        if not pyro_client_matches(PROCESSED_FRAME_IPS):
            return

        self._telescope.notify_processed_frame(headers)

    @Pyro4.expose
    def stop_telescope(self):
        """Cancels an active telescope task"""
        if not pyro_client_matches(CONTROL_IPS):
            return CommandStatus.InvalidControlIP

        return self._telescope.abort()

    @Pyro4.expose
    def schedule_observations(self, schedule):
        """Schedules actions to the telescope and dome"""
        if not pyro_client_matches(CONTROL_IPS):
            return CommandStatus.InvalidControlIP

        valid, _ = validate_schedule(schedule)
        if not valid:
            return CommandStatus.InvalidSchedule

        # TODO: Schedule dome times
        self._telescope.queue_actions(parse_schedule_actions(schedule))
        return CommandStatus.Succeeded

if __name__ == '__main__':
    daemons.onemetre_operations.launch(OperationsDaemon())
