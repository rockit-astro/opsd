#!/usr/bin/env python3
#
# This file is part of opsd.
#
# opsd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# opsd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with opsd.  If not, see <http://www.gnu.org/licenses/>.

"""Operations daemon for the Warwick one-metre telescope"""

# pylint: disable=invalid-name
# pylint: disable=broad-except
# pylint: disable=too-few-public-methods
# pylint: disable=too-many-branches
# pylint: disable=too-many-statements
# pylint: disable=too-many-instance-attributes

import datetime
import threading
import time
import Pyro4
import warwick.observatory as observatory

# TODO: Convert to new backend when we are able to test
DOME_HOST = '192.168.0.102'
DOME_PORT = 9004
DOME_NAME = 'dome_daemon'
DOME_URI = 'PYRO:' + DOME_NAME + '@' + DOME_HOST + ':' + str(DOME_PORT)

# Communications timeout when using the status and heartbeat commands (should be instant)
DOME_PYRO_STATUSHEARTBEAT_TIMEOUT = 5

# Communications timeout when opening or closing the dome (takes up to ~80 seconds)
DOME_PYRO_OPENCLOSE_TIMEOUT = 120

# Delay between ops and dome loop ticks (seconds)
LOOP_DELAY = 10

# Timeout period (seconds) for the dome controller
# The dome heartbeat is pinged once per LOOP_DELAY when the dome is under
# automatic control and is fully open or fully closed.  This timeout should
# be large enough to account for the time it takes to open and close the dome
DOME_HEARTBEAT_TIMEOUT = 120

# Exposure fudge factor to account for changing sky brightness
AUTOFLAT_EVENING_SCALE = 1.1
AUTOFLAT_DAWN_SCALE = 0.9

# Clamp exposure time deltas to this range (e.g. 5 -> 15 or 5 -> 1.6)
AUTOFLAT_MAX_EXPOSURE_DELTA = 3

AUTOFLAT_MIN_EXPOSURE = 0.1
AUTOFLAT_MAX_EXPOSURE = 30

# Exposures shorter than this will have large shutter effects and will be discarded
AUTOFLAT_MIN_SAVE_EXPOSURE = 2.5

# Exposures with less counts than this lack the signal to noise ratio that we desire
AUTOFLAT_MIN_SAVE_COUNTS = 20000

# Target flat counts to aim for
AUTOFLAT_TARGET_COUNTS = 35000

# Delays to apply between evening flats to save shutter cycles
# These delays are cumulative, so if the next exposure is calculated to be 0.9
# 0.9 seconds the routine will wait 5 + 25 = 30 seconds before starting it
AUTOFLAT_EVENING_EXPOSURE_DELAYS = {
    1: 25,
    2.5: 5
}

# This should be kept in sync with the dictionary in ops
class CommandStatus:
    """Numeric return codes"""
    # General error codes
    Succeeded = 0
    Failed = 1
    Blocked = 2
    InErrorState = 3

    CameraActive = 11

class OperationsMode:
    """Operational status"""
    Error, Automatic, Manual = range(3)
    Names = ['Error', 'Automatic', 'Manual']

class CameraStatus:
    """Camera status, from camd"""
    Disabled, Initializing, Idle, Acquiring, Reading, Aborting = range(6)

class DomeStatus:
    """Dome status, from domed"""
    Closed, Open, Moving, Timeout = range(4)
    Names = ['Closed', 'Open', 'Moving', 'Timeout']

def ParseDomeStatus(status):
    """Parses the return value from dome.status() into a DomeStatus"""
    if status[4] <= 0:
        return DomeStatus.Timeout
    if status[1] == 0 and status[2] == 0:
        return DomeStatus.Closed
    elif status[1] == 1 and status[2] == 1:
        return DomeStatus.Open
    else:
        return DomeStatus.Moving

class DomeCommandStatus:
    """Numeric return codes"""
    # General error codes
    Succeeded = 0
    Failed = 1
    Blocked = 2
    HeartbeatTimedOut = 3
    HeartbeatCloseInProgress = 4
    EastShutterMustBeFullyOpen = 10

class AutoFlatState:
    """Possible states of the AutoFlat routine"""
    Bias, Waiting, Saving, Complete = range(4)
    Names = ['Bias', 'Waiting', 'Saving', 'Complete']

class TryLock(object):
    """Helper object for use with `with` statements"""
    def __init__(self, lock):
        self._lock = lock
        self._locked = False

    def __enter__(self):
        self._locked = self._lock.acquire(False)
        return self._locked

    def __exit__(self, *args):
        if self._locked:
            self._lock.release()
            self._locked = False

class OperationsDaemon:
    """Daemon class that controls the overall observatory operations"""
    def __init__(self):
        self._command_lock = threading.Lock()

        self._observing = False

        # "public" interface for changing dome state
        self._dome_requested_mode = OperationsMode.Manual
        self._dome_requested_status = DomeStatus.Closed

        # internal dome state - take the lock writing or reading coherant state!
        self._dome_lock = threading.Lock()
        self._dome_mode = OperationsMode.Manual
        self._dome_status = DomeStatus.Closed
        self._dome_updated = datetime.datetime.utcnow()

        domeloop = threading.Thread(target=self.__dome_loop)
        domeloop.daemon = True
        domeloop.start()

        # environment state - take the lock before writing or reading coherant state!
        self._environment_lock = threading.Lock()
        self._environment_updated = datetime.datetime.utcnow()
        self._environment_safe = False

        self._frame_watchers = []
        self._telescope_lock = threading.Lock()
        self._telescope_condition = threading.Condition()
        self._telescope_active = False

        runloop = threading.Thread(target=self.__ops_loop)
        runloop.daemon = True
        runloop.start()

    def __dome_status(self, status):
        """Reports status back to the main thread in a thread-safe manner"""
        with self._dome_lock:
            self._dome_status = status
            self._dome_updated = datetime.datetime.utcnow()
            return status

    def __dome_mode(self, mode):
        """Reports status back to the main thread in a thread-safe manner"""
        with self._dome_lock:
            self._dome_mode = mode
            self._dome_updated = datetime.datetime.utcnow()
            return mode

    def __dome_loop(self):
        """Thread that controls dome opening/closing to match requested state"""
        while True:
            # Handle requests from the user to change between manual and automatic mode
            # Manual intervention is required to clear errors and return to automatic mode.
            # If an error does occur the dome heartbeat will timeout, and it will close itself.
            auto_failure = self._dome_mode == OperationsMode.Error and \
                self._dome_requested_mode == OperationsMode.Automatic

            if self._dome_requested_mode != self._dome_mode and not auto_failure:
                print('dome: changing mode from ' + OperationsMode.Names[self._dome_mode] + \
                    ' to ' + OperationsMode.Names[self._dome_requested_mode])

                try:
                    with Pyro4.Proxy(DOME_URI) as dome:
                        # pylint: disable=protected-access
                        dome._pyroTimeout = DOME_PYRO_STATUSHEARTBEAT_TIMEOUT
                        # pylint: enable=protected-access
                        if self._dome_requested_mode == OperationsMode.Automatic:
                            # TODO: Change this to lock to ops mode
                            ret = dome.configure_heartbeat(DOME_HEARTBEAT_TIMEOUT)
                            if ret == DomeCommandStatus.Succeeded:
                                self.__dome_mode(OperationsMode.Automatic)
                            else:
                                print('error: failed to switch dome to auto with error: ', ret)
                                self.__dome_mode(OperationsMode.Error)
                        else:
                            # Switch from auto or error state back to manual
                            with Pyro4.Proxy(DOME_URI) as dome:
                                # TODO: Change this to unlock from ops mode
                                # TODO: the dome daemon should disable the ops lock if it times out
                                ret = dome.configure_heartbeat(0)

                            if ret == DomeCommandStatus.Succeeded:
                                self.__dome_mode(OperationsMode.Manual)
                            else:
                                print('error: failed to switch dome to manual with error: ', ret)
                                self.__dome_mode(OperationsMode.Error)
                except Exception as e:
                    print('error: failed to communicate with the dome daemon: ', e)
                    self.__dome_mode(OperationsMode.Error)

            if self._dome_mode == OperationsMode.Automatic:
                try:
                    with Pyro4.Proxy(DOME_URI) as dome:
                        # pylint: disable=protected-access
                        dome._pyroTimeout = DOME_PYRO_STATUSHEARTBEAT_TIMEOUT
                        # pylint: enable=protected-access
                        status = self.__dome_status(ParseDomeStatus(dome.status()))
                        wants_status = self._dome_requested_status
                        print('dome: is ' +  DomeStatus.Names[status] + ' and wants to be ' + \
                            DomeStatus.Names[wants_status])

                        if status == DomeStatus.Timeout:
                            print('dome: detected heartbeat timeout!')
                            self.__dome_mode(OperationsMode.Error)
                        elif wants_status == DomeStatus.Closed and status == DomeStatus.Open:
                            print('dome: sending heartbeat ping before closing')
                            dome.ping_heartbeat()
                            print('dome: closing')
                            self.__dome_status(DomeStatus.Moving)
                            # pylint: disable=protected-access
                            dome._pyroTimeout = DOME_PYRO_OPENCLOSE_TIMEOUT
                            ret = dome.close_shutters(east=True, west=True)
                            dome._pyroTimeout = DOME_PYRO_STATUSHEARTBEAT_TIMEOUT
                            # pylint: enable=protected-access
                            if ret == DomeCommandStatus.Succeeded:
                                self.__dome_status(DomeStatus.Closed)
                            else:
                                self.__dome_mode(OperationsMode.Error)
                        elif wants_status == DomeStatus.Open and status == DomeStatus.Closed:
                            print('dome: sending heartbeat ping before opening')
                            dome.ping_heartbeat()
                            print('dome: opening')
                            self.__dome_status(DomeStatus.Moving)
                            # pylint: disable=protected-access
                            dome._pyroTimeout = DOME_PYRO_OPENCLOSE_TIMEOUT
                            ret = dome.open_shutters(east=True, west=True)
                            dome._pyroTimeout = DOME_PYRO_STATUSHEARTBEAT_TIMEOUT
                            # pylint: enable=protected-access
                            if ret == DomeCommandStatus.Succeeded:
                                self.__dome_status(DomeStatus.Open)
                            else:
                                self.__dome_mode(OperationsMode.Error)
                        elif status == wants_status:
                            print('dome: sending heartbeat ping')
                            dome.ping_heartbeat()
                except Exception as e:
                    print('error: failed to communicate with the dome daemon: ', e)
                    self.__dome_mode(OperationsMode.Error)

            time.sleep(LOOP_DELAY)

    def __environment_safe(self, safe):
        """Reports status back to the main thread in a thread-safe manner"""
        with self._environment_lock:
            self._environment_safe = safe
            self._environment_updated = datetime.datetime.utcnow()
            return safe

    def __ops_loop(self):
        """Main operations run loop."""
        environment_safe = False
        while True:
            was_safe = environment_safe
            try:
                with observatory.daemons.onemetre_environment.connect() as environment:
                    status = environment.status()
                environment_safe = status['can_observe']
                if was_safe and not environment_safe:
                    observatory.log.warning('opsd', 'Environment has become unsafe')
                elif not was_safe and environment_safe:
                    observatory.log.info('opsd', 'Environment trigger timed out')
            except Exception as e:
                environment_safe = False
                print('error: failed to query environment: ', e)
                observatory.log.info('opsd', 'Failed to query environmentd (' + str(e) + ')')

            self.__environment_safe(environment_safe)
            if self._dome_requested_status == DomeStatus.Open and not environment_safe:
                print('closing dome due to environment alert')
                print('environment status is:')
                print(status)

            # Cancel observing if the weather turns bad
            if not environment_safe and self._observing:
                self._observing = False
                observatory.log.info('opsd', 'Observing condition automatically disabled')

            self._dome_requested_status = DomeStatus.Open if self._observing else DomeStatus.Closed

            # Check for requested status changes
            time.sleep(LOOP_DELAY)

    @Pyro4.expose
    def dome_control(self, automatic):
        """Switch the dome between manual (observer) and automatic (opsd) control"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # TODO: Require dome to be fully closed or open before switching to automatic
            if automatic and self._dome_mode == OperationsMode.Error:
                return CommandStatus.InErrorState

            self._dome_requested_mode = OperationsMode.Automatic if automatic else \
                OperationsMode.Manual

            observatory.log.info('opsd', 'Dome control manually changed to '
                                 + ('automatic' if automatic else 'manual'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_observing(self, observing):
        """Enable or disable the global observing mode (opens the dome)"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if observing and self._dome_mode == OperationsMode.Error:
                return CommandStatus.InErrorState

            self._observing = observing
            observatory.log.info('opsd', 'Observing condition manually '
                                 + ('enabled' if observing else 'disabled'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def status(self):
        """Query the latest status."""
        data = {'observing': self._observing}

        with self._environment_lock:
            data.update({
                'environment_safe': self._environment_safe,
                'environment_updated': self._environment_updated.strftime('%Y-%m-%dT%H:%M:%SZ')
            })

        with self._dome_lock:
            data.update({
                'dome_mode': self._dome_mode,
                'dome_status': self._dome_status,
                'dome_updated': self._dome_updated.strftime('%Y-%m-%dT%H:%M:%SZ'),
                'dome_requested_mode': self._dome_requested_mode,
                'dome_requested_status': self._dome_requested_status
            })

        return data

    @Pyro4.expose
    def notify_processed_frame(self, headers):
        """Called by the pipeline daemon to notify that a new frame has completed processing
           headers is a dictionary holding the key-value pairs from the fits header"""
        for f in self._frame_watchers:
            f(headers)

    @Pyro4.expose
    def autoflat(self):
        """Automatically runs the cameras (and eventually the telescope) to acquire flat frames"""
        with TryLock(self._telescope_lock) as success:
            if not success:
                return CommandStatus.Blocked

            bias = {
                'BLUE': 0,
                'RED': 0
            }

            state = {
                'BLUE': AutoFlatState.Bias,
                'RED': AutoFlatState.Bias
            }

            daemon = {
                'BLUE': observatory.daemons.onemetre_blue_camera,
                'RED': observatory.daemons.onemetre_red_camera,
            }

            # Account for the setting or rising sun
            is_evening = datetime.datetime.utcnow().hour > 12
            scale = AUTOFLAT_EVENING_SCALE if is_evening else AUTOFLAT_DAWN_SCALE

            def received_frame(headers):
                """Callback to process an acquired frame.  headers is a dictionary of header keys"""
                arm = None
                try:
                    arm = headers['INSTRARM']
                    last_state = state[arm]

                    if state[arm] == AutoFlatState.Bias:
                        bias[arm] = headers['MEDCNTS']
                        print(arm + ' bias level is {:.0f} ADU'.format(headers['MEDCNTS']))
                        # Take the first flat image
                        state[arm] = AutoFlatState.Waiting
                        with daemon[arm].connect() as cam:
                            start_exp = AUTOFLAT_MIN_EXPOSURE if is_evening \
                                else AUTOFLAT_MIN_SAVE_EXPOSURE
                            cam.set_exposure(start_exp)
                            cam.set_shutter(True)
                            cam.start_sequence(1)

                    elif state[arm] == AutoFlatState.Waiting or state[arm] == AutoFlatState.Saving:
                        exposure = headers['EXPTIME']
                        counts = headers['MEDCNTS'] - bias[headers['INSTRARM']]

                        # If the count rate is too low then we scale the exposure by the max amount
                        if counts > 0:
                            new_exposure = scale * exposure * AUTOFLAT_TARGET_COUNTS / counts
                        else:
                            new_exposure = exposure * AUTOFLAT_MAX_EXPOSURE_DELTA

                        # Clamp the exposure to a sensible range
                        clamped_exposure = min(new_exposure, AUTOFLAT_MAX_EXPOSURE,
                                               exposure * AUTOFLAT_MAX_EXPOSURE_DELTA)
                        clamped_exposure = max(clamped_exposure, AUTOFLAT_MIN_EXPOSURE,
                                               exposure / AUTOFLAT_MAX_EXPOSURE_DELTA)

                        clamped_desc = ' (clamped from {:.2f}s)'.format(new_exposure) \
                            if new_exposure > clamped_exposure else ''
                        print(arm + ' exposure {:.2f}s counts {:.0f} ADU -> {:.2f}s{}'
                              .format(exposure, counts, clamped_exposure, clamped_desc))

                        if is_evening:
                            # Sky is decreasing in brightness
                            # TODO: Remove this once we account for sun elevation?
                            for min_exposure in AUTOFLAT_EVENING_EXPOSURE_DELAYS:
                                if new_exposure < min_exposure \
                                        and counts > AUTOFLAT_MIN_SAVE_COUNTS:
                                    delay = AUTOFLAT_EVENING_EXPOSURE_DELAYS[min_exposure]
                                    print(arm + ' waiting ' + str(delay) + 's for it to get darker')
                                    time.sleep(delay)

                            if clamped_exposure == AUTOFLAT_MAX_EXPOSURE \
                                    and counts < AUTOFLAT_MIN_SAVE_COUNTS:
                                state[arm] = AutoFlatState.Complete
                            elif state[arm] == AutoFlatState.Waiting \
                                    and counts > AUTOFLAT_MIN_SAVE_COUNTS \
                                    and new_exposure > AUTOFLAT_MIN_SAVE_EXPOSURE:
                                state[arm] = AutoFlatState.Saving
                        else:
                            # Sky is increasing in brightness
                            if clamped_exposure < AUTOFLAT_MIN_SAVE_EXPOSURE:
                                state[arm] = AutoFlatState.Complete
                            elif state[arm] == AutoFlatState.Waiting \
                                    and counts > AUTOFLAT_MIN_SAVE_COUNTS:
                                state[arm] = AutoFlatState.Saving

                        if state[arm] != last_state:
                            with observatory.daemons.onemetre_pipeline.connect() as pipeline:
                                if state[arm] == AutoFlatState.Saving:
                                    pipeline.set_archive(arm, True)
                                else:
                                    pipeline.set_archive(arm, False)

                        if last_state != state[arm]:
                            print(arm + ' ' + AutoFlatState.Names[last_state] + ' -> ' \
                                + AutoFlatState.Names[state[arm]])

                        if state[arm] != AutoFlatState.Complete:
                            with daemon[arm].connect() as cam:
                                cam.set_exposure(clamped_exposure)
                                cam.start_sequence(1)
                except Exception as e:
                    print('failed to parse frame callback for arm ' + str(arm))
                    print(e)
                    if arm is not None:
                        state[arm] = AutoFlatState.Complete

            self._frame_watchers.append(received_frame)
            try:
                with self._telescope_condition:
                    self._telescope_active = True
                    # Give up early if the cameras are running
                    for arm in daemon:
                        with daemon[arm].connect() as cam:
                            if cam.report_status()['state'] != CameraStatus.Idle:
                                return CommandStatus.CameraActive

                    with observatory.daemons.onemetre_pipeline.connect() as pipeline:
                        pipeline.set_intensity_stats(True)
                        pipeline.set_output_frame_prefix('flat')
                        pipeline.set_frame_type('FLAT')
                        for arm in daemon:
                            pipeline.set_archive(arm, False)

                    # TODO: Wait for sun to get to about the right elevation to save shutter cycles
                    # Acquire bias frame
                    for arm in daemon:
                        with daemon[arm].connect() as cam:
                            cam.set_shutter(False)
                            cam.set_exposure(0)
                            cam.start_sequence(1)

                    while True:
                        self._telescope_condition.wait(5)
                        if all([state[arm] == AutoFlatState.Complete for arm in state]):
                            return CommandStatus.Succeeded

                        if not self._telescope_active:
                            return CommandStatus.Failed

                return CommandStatus.Succeeded
            except Exception as e:
                print('exception during autoflat:')
                print(e)
                return CommandStatus.Failed
            finally:
                self._telescope_active = False
                self._frame_watchers.remove(received_frame)
                with observatory.daemons.onemetre_pipeline.connect() as pipeline:
                    pipeline.set_intensity_stats(False)

    @Pyro4.expose
    def stop_telescope(self):
        """Cancels an active telescope task"""
        self._telescope_active = False
        with self._telescope_condition:
            self._telescope_condition.notify_all()

        return CommandStatus.Succeeded

if __name__ == '__main__':
    observatory.daemons.onemetre_operations.launch(OperationsDaemon())

