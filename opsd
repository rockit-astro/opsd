#!/usr/bin/env python3
#
# This file is part of opsd.
#
# opsd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# opsd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with opsd.  If not, see <http://www.gnu.org/licenses/>.

"""Operations daemon for the Warwick one-metre telescope"""

# pylint: disable=invalid-name
# pylint: disable=broad-except
# pylint: disable=too-many-branches
# pylint: disable=too-many-statements
# pylint: disable=too-many-return-statements
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-locals
# pylint: disable=too-few-public-methods

import datetime
import sys
import threading
import time
from astropy.coordinates import SkyCoord
from astropy import units as u
from astropy.wcs import WCS
import Pyro4
from warwick.observatory.common import (
    daemons,
    log,
    TryLock)

from warwick.w1m.operations import (
    DomeController,
    DomeStatus,
    CommandStatus,
    OperationsMode,
    AutoFlatState
)

from warwick.w1m.environment import (
    ParameterStatus
)

# Include more detailed exceptions
sys.excepthook = Pyro4.util.excepthook

TEL_DAEMON = daemons.onemetre_telescope
PIPELINE_DAEMON = daemons.onemetre_pipeline
ENVIRONMENT_DAEMON = daemons.onemetre_environment
POWER_DAEMON = daemons.onemetre_power

CAM_DAEMON = {
    'BLUE': daemons.onemetre_blue_camera,
    'RED': daemons.onemetre_red_camera
}

# Communications timeout when opening or closing the dome (takes up to ~80 seconds)
DOME_PYRO_OPENCLOSE_TIMEOUT = 120

# Delay between ops and dome loop ticks (seconds)
LOOP_DELAY = 10

# Timeout period (seconds) for the dome controller
# The dome heartbeat is pinged once per LOOP_DELAY when the dome is under
# automatic control and is fully open or fully closed.  This timeout should
# be large enough to account for the time it takes to open and close the dome
DOME_HEARTBEAT_TIMEOUT = 119

# Exposure fudge factor to account for changing sky brightness
AUTOFLAT_EVENING_SCALE = 1.1
AUTOFLAT_DAWN_SCALE = 0.9

# Clamp exposure time deltas to this range (e.g. 5 -> 15 or 5 -> 1.6)
AUTOFLAT_MAX_EXPOSURE_DELTA = 3

AUTOFLAT_MIN_EXPOSURE = 0.1
AUTOFLAT_MAX_EXPOSURE = 30

# Exposures shorter than this will have large shutter effects and will be discarded
AUTOFLAT_MIN_SAVE_EXPOSURE = 2.5

# Exposures with less counts than this lack the signal to noise ratio that we desire
AUTOFLAT_MIN_SAVE_COUNTS = 20000

# Target flat counts to aim for
AUTOFLAT_TARGET_COUNTS = 35000

# Delays to apply between evening flats to save shutter cycles
# These delays are cumulative, so if the next exposure is calculated to be 0.9
# 0.9 seconds the routine will wait 5 + 25 = 30 seconds before starting it
AUTOFLAT_EVENING_EXPOSURE_DELAYS = {
    1: 25,
    2.5: 5
}

AUTOACQUIRE_EXPOSURE_LENGTH = 10

# Additional maximum wait time for readout + pipeline processing
AUTOACQUIRE_MAX_READOUT_PROCESS_TIME = 15

# Aim for an accuracy of 1 arcsec
AUTOACQUIRE_POINTING_THRESHOLD = 1.0

# Number of attempts before we give up
AUTOACQUIRE_ADJUST_ATTEMPTS = 5

AUTOACQUIRE_WCS_ATTEMPTS = 3

# Offset in radians to transform red camera coordinates to blue camera coordinates
# pylint: disable=no-member
AUTOACQUIRE_RED_CAMERA_OFFSET = (2.043859e-4 * u.radian, 4.899995e-6 * u.radian)
# pylint: enable=no-member

AUTOACQUIRE_SLEW_TIMEOUT = 60

# This should be kept in sync with the dictionary in ops
class CameraStatus:
    """Camera status, from camd"""
    Disabled, Initializing, Idle, Acquiring, Reading, Aborting = range(6)

class OperationsDaemon:
    """Daemon class that controls the overall observatory operations"""
    def __init__(self):
        self._command_lock = threading.Lock()

        self._observing = False

        self._dome = DomeController(
            daemons.onemetre_dome,
            DOME_PYRO_OPENCLOSE_TIMEOUT,
            DOME_HEARTBEAT_TIMEOUT,
            LOOP_DELAY)

        # environment state - take the lock before writing or reading coherant state!
        self._environment_lock = threading.Lock()
        self._environment_updated = datetime.datetime.utcnow()
        self._environment_safe = False

        self._frame_watchers = []
        self._telescope_lock = threading.Lock()
        self._telescope_condition = threading.Condition()
        self._telescope_active = False

        runloop = threading.Thread(target=self.__ops_loop)
        runloop.daemon = True
        runloop.start()

    def __environment_safe(self, safe):
        """Reports status back to the main thread in a thread-safe manner"""
        with self._environment_lock:
            self._environment_safe = safe
            self._environment_updated = datetime.datetime.utcnow()
            return safe

    def __ops_loop(self):
        """Main operations run loop."""
        environment_safe = False
        while True:
            was_safe = environment_safe
            try:
                with ENVIRONMENT_DAEMON.connect() as environment:
                    status = environment.status()

                environment_safe = not any(status[sensor]['status'] == ParameterStatus.Unsafe \
                    for sensor in status)

                if was_safe and not environment_safe:
                    log.warning('opsd', 'Environment has become unsafe')
                elif not was_safe and environment_safe:
                    log.info('opsd', 'Environment trigger timed out')
            except Exception as e:
                environment_safe = False
                print('error: failed to query environment: ', e)
                log.info('opsd', 'Failed to query environmentd (' + str(e) + ')')

            self.__environment_safe(environment_safe)

            dome_status = self._dome.status()
            if dome_status['requested_status'] == DomeStatus.Open and not environment_safe:
                print('closing dome due to environment alert')
                print('environment status is:')
                print(status)

            if dome_status['mode'] == OperationsMode.Error:
                self._observing = False
                log.warning('opsd', 'Observing condition disabled because of dome error')

            if not environment_safe and self._observing:
                self._observing = False
                log.warning('opsd', 'Observing condition automatically disabled')


            self._dome.request_status(DomeStatus.Open if self._observing else DomeStatus.Closed)

            # Check for requested status changes
            time.sleep(LOOP_DELAY)

    @Pyro4.expose
    def dome_control(self, automatic):
        """Switch the dome between manual (observer) and automatic (opsd) control"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # Require dome to be fully closed or open before switching to automatic
            dome_status = self._dome.status()
            if automatic and dome_status['mode'] == OperationsMode.Error:
                return CommandStatus.InErrorState

            mode = OperationsMode.Automatic if automatic else OperationsMode.Manual
            self._dome.request_mode(mode)

            log.info('opsd', 'Dome control manually changed to '
                     + ('automatic' if automatic else 'manual'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_observing(self, observing):
        """Enable or disable the global observing mode (opens the dome)"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            dome_status = self._dome.status()
            if observing and dome_status['mode'] == OperationsMode.Error:
                return CommandStatus.InErrorState

            self._observing = observing
            log.info('opsd', 'Observing condition manually '
                     + ('enabled' if observing else 'disabled'))

            return CommandStatus.Succeeded

    @Pyro4.expose
    def status(self):
        """Query the latest status."""
        data = {
            'observing': self._observing,
            'dome': self._dome.status()
        }

        with self._environment_lock:
            data.update({
                'environment_safe': self._environment_safe,
                'environment_updated': self._environment_updated.strftime('%Y-%m-%dT%H:%M:%SZ')
            })

        return data

    @Pyro4.expose
    def notify_processed_frame(self, headers):
        """Called by the pipeline daemon to notify that a new frame has completed processing
           headers is a dictionary holding the key-value pairs from the fits header"""
        for f in self._frame_watchers:
            f(headers)

    @Pyro4.expose
    def autoflat(self):
        """Automatically runs the cameras (and eventually the telescope) to acquire flat frames"""
        with TryLock(self._telescope_lock) as success:
            if not success:
                return CommandStatus.Blocked

            bias = {
                'BLUE': 0,
                'RED': 0
            }

            state = {
                'BLUE': AutoFlatState.Bias,
                'RED': AutoFlatState.Bias
            }

            # Account for the setting or rising sun
            is_evening = datetime.datetime.utcnow().hour > 12
            scale = AUTOFLAT_EVENING_SCALE if is_evening else AUTOFLAT_DAWN_SCALE

            def received_frame(headers):
                """Callback to process an acquired frame.  headers is a dictionary of header keys"""
                arm = None
                try:
                    arm = headers['INSTRARM']
                    last_state = state[arm]

                    if state[arm] == AutoFlatState.Bias:
                        bias[arm] = headers['MEDCNTS']
                        print(arm + ' bias level is {:.0f} ADU'.format(bias[arm]))
                        log.info('opsd', '{} bias is {:.0f} ADU'.format(arm, bias[arm]))

                        # Take the first flat image
                        state[arm] = AutoFlatState.Waiting
                        with CAM_DAEMON[arm].connect() as cam:
                            start_exp = AUTOFLAT_MIN_EXPOSURE if is_evening \
                                else AUTOFLAT_MIN_SAVE_EXPOSURE
                            cam.set_exposure(start_exp)
                            cam.set_shutter(True)
                            cam.start_sequence(1)

                    elif state[arm] == AutoFlatState.Waiting or state[arm] == AutoFlatState.Saving:
                        exposure = headers['EXPTIME']
                        counts = headers['MEDCNTS'] - bias[headers['INSTRARM']]

                        # If the count rate is too low then we scale the exposure by the max amount
                        if counts > 0:
                            new_exposure = scale * exposure * AUTOFLAT_TARGET_COUNTS / counts
                        else:
                            new_exposure = exposure * AUTOFLAT_MAX_EXPOSURE_DELTA

                        # Clamp the exposure to a sensible range
                        clamped_exposure = min(new_exposure, AUTOFLAT_MAX_EXPOSURE,
                                               exposure * AUTOFLAT_MAX_EXPOSURE_DELTA)
                        clamped_exposure = max(clamped_exposure, AUTOFLAT_MIN_EXPOSURE,
                                               exposure / AUTOFLAT_MAX_EXPOSURE_DELTA)

                        clamped_desc = ' (clamped from {:.2f}s)'.format(new_exposure) \
                            if new_exposure > clamped_exposure else ''
                        print(arm + ' exposure {:.2f}s counts {:.0f} ADU -> {:.2f}s{}'
                              .format(exposure, counts, clamped_exposure, clamped_desc))

                        log.info('opsd', 'autoflat: {} {:.2f}s {:.0f} ADU -> {:.2f}s{}'
                                 .format(arm, exposure, counts, clamped_exposure, clamped_desc))

                        if is_evening:
                            # Sky is decreasing in brightness
                            # TODO: Remove this once we account for sun elevation?
                            for min_exposure in AUTOFLAT_EVENING_EXPOSURE_DELAYS:
                                if new_exposure < min_exposure \
                                        and counts > AUTOFLAT_MIN_SAVE_COUNTS:
                                    delay = AUTOFLAT_EVENING_EXPOSURE_DELAYS[min_exposure]
                                    print(arm + ' waiting ' + str(delay) + 's for it to get darker')
                                    time.sleep(delay)

                            if clamped_exposure == AUTOFLAT_MAX_EXPOSURE \
                                    and counts < AUTOFLAT_MIN_SAVE_COUNTS:
                                state[arm] = AutoFlatState.Complete
                            elif state[arm] == AutoFlatState.Waiting \
                                    and counts > AUTOFLAT_MIN_SAVE_COUNTS \
                                    and new_exposure > AUTOFLAT_MIN_SAVE_EXPOSURE:
                                state[arm] = AutoFlatState.Saving
                        else:
                            # Sky is increasing in brightness
                            if clamped_exposure < AUTOFLAT_MIN_SAVE_EXPOSURE:
                                state[arm] = AutoFlatState.Complete
                            elif state[arm] == AutoFlatState.Waiting \
                                    and counts > AUTOFLAT_MIN_SAVE_COUNTS:
                                state[arm] = AutoFlatState.Saving

                        if state[arm] != last_state:
                            with PIPELINE_DAEMON.connect() as pipeline:
                                if state[arm] == AutoFlatState.Saving:
                                    pipeline.set_archive(arm, True)
                                else:
                                    pipeline.set_archive(arm, False)

                        if last_state != state[arm]:
                            print('autoflat: ' + arm + ' ' + AutoFlatState.Names[last_state] \
                                + ' -> ' + AutoFlatState.Names[state[arm]])
                            log.info('opsd', 'autoflat: {} arm {} -> {}'.format(
                                arm, AutoFlatState.Names[last_state],
                                AutoFlatState.Names[state[arm]]))

                        if state[arm] != AutoFlatState.Complete:
                            with CAM_DAEMON[arm].connect() as cam:
                                cam.set_exposure(clamped_exposure)
                                cam.start_sequence(1)
                except Exception as e:
                    print('autoflat: failed to parse frame callback for arm ' + str(arm))
                    print(e)
                    if arm is not None:
                        state[arm] = AutoFlatState.Complete

            self._frame_watchers.append(received_frame)
            try:
                with self._telescope_condition:
                    self._telescope_active = True
                    # Give up early if the cameras are running
                    for arm in CAM_DAEMON:
                        with CAM_DAEMON[arm].connect() as cam:
                            if cam.report_status()['state'] != CameraStatus.Idle:
                                return CommandStatus.CameraActive

                    with PIPELINE_DAEMON.connect() as pipeline:
                        pipeline.set_intensity_stats(True)
                        pipeline.set_output_frame_prefix('flat')
                        pipeline.set_frame_type('FLAT')
                        for arm in CAM_DAEMON:
                            pipeline.set_archive(arm, False)

                    # TODO: Wait for sun to get to about the right elevation to save shutter cycles
                    # Acquire bias frame
                    for arm in CAM_DAEMON:
                        with CAM_DAEMON[arm].connect() as cam:
                            cam.set_shutter(False)
                            cam.set_exposure(0)
                            cam.start_sequence(1)

                    while True:
                        self._telescope_condition.wait(5)
                        if all([state[arm] == AutoFlatState.Complete for arm in state]):
                            return CommandStatus.Succeeded

                        if not self._telescope_active:
                            return CommandStatus.Failed

                return CommandStatus.Succeeded
            except Exception as e:
                print('autoflat: caught exception:')
                print(e)
                return CommandStatus.Failed
            finally:
                self._telescope_active = False
                self._frame_watchers.remove(received_frame)
                with PIPELINE_DAEMON.connect() as pipeline:
                    pipeline.set_intensity_stats(False)

    @Pyro4.expose
    def acquire_field(self, ra_radians, dec_radians):
        """Automatically home in on a target position"""
        with TryLock(self._telescope_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # Coordinates extracted from the frame
            coordinates = {
                'BLUE': None,
                'RED': None,
            }

            processed = {
                'BLUE': False,
                'RED': False
            }

            target = SkyCoord(ra_radians, dec_radians, unit='radian')

            def received_frame(headers):
                """Callback to process an acquired frame. headers is a dictionary of header keys"""
                arm = None
                try:
                    arm = headers['INSTRARM']

                    # Read WCS cooordinates from frame and convert to (ra,dec) in radians at center
                    if 'CTYPE1' in headers and 'CTYPE2' in headers:
                        w = WCS(headers)
                        # TODO: transform this to the center of the FOV (accounting for windowing)
                        center_x = headers['NAXIS1'] / 2
                        center_y = headers['NAXIS2'] / 2
                        ra_deg, dec_deg = w.all_pix2world(center_x, center_y, 0)

                        pos = SkyCoord(ra_deg, dec_deg, unit='deg')
                        pos_str = pos.to_string('hmsdms', sep=':')
                        print('autoacquire: solved {} field center: {}'.format(arm, pos_str))
                        coordinates[arm] = pos
                except Exception as e:
                    print('autoacquire: failed to parse frame callback for arm ' + str(arm))
                    print(e)
                finally:
                    processed[arm] = True

                    # Wake up the main thread if all frames have been received
                    if all([processed[arm] for arm in processed]):
                        with self._telescope_condition:
                            self._telescope_condition.notify_all()

            self._frame_watchers.append(received_frame)
            try:
                with self._telescope_condition:
                    self._telescope_active = True
                    # Give up early if the cameras are running
                    for arm in CAM_DAEMON:
                        with CAM_DAEMON[arm].connect() as cam:
                            if cam.report_status()['state'] != CameraStatus.Idle:
                                return CommandStatus.CameraActive

                    # Give up early if the drive power is disabled
                    with POWER_DAEMON.connect() as power:
                        if not power.value('telescope_80v'):
                            return CommandStatus.TelescopeSlewFailed

                    with PIPELINE_DAEMON.connect() as pipeline:
                        pipeline.set_wcs(True)
                        for arm in CAM_DAEMON:
                            pipeline.set_archive(arm, False)

                    # Move the telescope to the requested coordinates
                    # This will be accurate to within a few arcmin
                    with TEL_DAEMON.connect(timeout=AUTOACQUIRE_SLEW_TIMEOUT) as tel:
                        target_str = target.to_string('hmsdms', sep=':')
                        print('autoacquire: slewing to {}'.format(target_str))
                        log.info('opsd', 'autoacquire: slewing telescope to {}'.format(
                            target_str))
                        telstatus = tel.track_radec(ra_radians, dec_radians)
                        if telstatus != CommandStatus.Succeeded:
                            print('autoacquire: failed to move telescope with error ' \
                                  + str(telstatus))
                            log.info('opsd', 'autoacquire: slew failed')
                            return CommandStatus.TelescopeSlewFailed

                    # Wait a few of seconds for the telescope position to stabilize
                    time.sleep(5)

                    # Refine positioning by taking images and using the WCS to adjust
                    adjust_attempts = 0
                    wcs_attempts = 0
                    while True:
                        for arm in CAM_DAEMON:
                            processed[arm] = False
                            coordinates[arm] = None
                            print('autoacquire: starting test image in ' + arm)
                            with CAM_DAEMON[arm].connect() as cam:
                                # todo: reset windowing
                                cam.set_shutter(True)
                                cam.set_exposure(AUTOACQUIRE_EXPOSURE_LENGTH)
                                cam.start_sequence(1)

                        # Wait for exposure + max timeout
                        # Will be woken up early once all frames are received
                        wait = AUTOACQUIRE_EXPOSURE_LENGTH + AUTOACQUIRE_MAX_READOUT_PROCESS_TIME
                        self._telescope_condition.wait(wait)
                        if not self._telescope_active:
                            return CommandStatus.Failed

                        blue_str = None
                        if coordinates['BLUE'] is not None:
                            blue_str = coordinates['BLUE'].to_string('hmsdms', sep=':')

                        red_str = None
                        if coordinates['RED'] is not None:
                            red_str = coordinates['RED'].to_string('hmsdms', sep=':')

                        print('autoacquire: solved field centers:')
                        print('   BLUE: ', blue_str)
                        print('   RED: ', red_str)

                        position = None
                        position_arm = None
                        if coordinates['BLUE'] is not None:
                            position = coordinates['BLUE']
                            position_arm = 'BLUE'
                        elif coordinates['RED'] is not None:
                            c = coordinates['RED']
                            o = AUTOACQUIRE_RED_CAMERA_OFFSET
                            position = SkyCoord(c.ra + o[0], c.dec + o[1])
                            position_arm = 'RED'

                        if wcs_attempts >= AUTOACQUIRE_WCS_ATTEMPTS:
                            log.info('opsd', 'autoacquire: WCS failed')
                            return CommandStatus.CoordinateSolutionFailed

                        if position is None:
                            wcs_attempts += 1
                            print('autoacquire: WCS attempt {} of {} failed'.format(
                                wcs_attempts, AUTOACQUIRE_WCS_ATTEMPTS))

                            # return to start of loop to try another exposure
                            continue
                        else:
                            wcs_attempts = 0

                        if not self._telescope_active:
                            return CommandStatus.Failed

                        # TODO: Requires newer astropy!
                        # offset = position.spherical_offsets_to(target)
                        delta_ra = target.ra - position.ra
                        delta_dec = target.dec - position.dec
                        separation = position.separation(target).arcsecond

                        if adjust_attempts > AUTOACQUIRE_ADJUST_ATTEMPTS:
                            print('autoacquire: giving up after ' + str(adjust_attempts) \
                                  + ' attempts with {:.2f} arcsec delta'.format(separation))
                            log.info('opsd', 'autoacquire: pointing failed to converge')
                            return CommandStatus.Failed

                        # Apply offset or break if close enough
                        if separation < AUTOACQUIRE_POINTING_THRESHOLD:
                            print('autoacquire: reached target with delta {:.2f} arcsec'.format(
                                separation))
                            log.info('opsd', 'autoacquire: pointing complete')
                            return CommandStatus.Succeeded

                        # pylint: disable=no-member
                        delta_ra_str = delta_ra.to_string(u.hourangle, sep=':')
                        # pylint: enable=no-member
                        delta_dec_str = delta_dec.to_string(sep=':')
                        print('autoacquire: applying offset from {}: {}, {}'.format(
                            position_arm, delta_ra_str, delta_dec_str))
                        log.info('opsd', 'autoacquire: offsetting telescope by {} {}'
                                 .format(delta_ra_str, delta_dec_str))

                        with TEL_DAEMON.connect(timeout=AUTOACQUIRE_SLEW_TIMEOUT) as tel:
                            telstatus = tel.offset_radec(delta_ra.radian, delta_dec.radian)
                            if telstatus != CommandStatus.Succeeded:
                                print('autoacquire: failed to move telescope with error ' \
                                      + str(telstatus))
                                return CommandStatus.TelescopeSlewFailed

                        # Wait a few of seconds for the telescope position to stabilize
                        time.sleep(5)
                        adjust_attempts += 1
                        if not self._telescope_active:
                            return CommandStatus.Failed

            except Exception as e:
                print('autoacquire: caught exception:')
                print(e)
                return CommandStatus.Failed
            finally:
                self._telescope_active = False
                self._frame_watchers.remove(received_frame)

    @Pyro4.expose
    def stop_telescope(self):
        """Cancels an active telescope task"""
        self._telescope_active = False
        with self._telescope_condition:
            self._telescope_condition.notify_all()

        return CommandStatus.Succeeded

if __name__ == '__main__':
    daemons.onemetre_operations.launch(OperationsDaemon())
